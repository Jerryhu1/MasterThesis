toRight <- !toLeft
leftNode <- x[toLeft,]
rightNode <- x[toRight,]
# Recursively construct the tree
leftChild <- tree.grow(leftNode, y[toLeft], nmin, minleaf, nfeat)
rightChild <- tree.grow(rightNode, y[toRight], nmin, minleaf, nfeat)
# Add labels to the matrix so we can access them easier
names(leftChild) <- c("node", "leftChild", "rightChild", "feature","splitValue","label")
names(rightChild) <- c("node", "leftChild", "rightChild", "feature","splitValue","label")
# Construct the root node
tree <- data.frame(idNode, leftChild[1,1], rightChild[1,1],split$feature, split$val,round(sum(y)/length(y)))
names(tree) <- c("node", "leftChild", "rightChild", "feature","splitValue", "label")
# Combine the branches to one tree and return
return(rbind(rbind(tree, leftChild), rightChild))
}
tree.grow(indian.x, y, 5,20,8)
debugSource('B:/School/Master/Data Mining/INFOMDM/Assignment1/R-scripts/tree.R', echo=TRUE)
# Set the node incrementer
tree.grow(indian.x, y, 5,20,8)
nodeIdx
ndoeIdx
nodeIdx
tree.grow1 <- function(x,y,nmin,minleaf,nfeat){
# Set the node incrementer
idNode <- nodeIdx
nodeIdx <<- nodeIdx + 1
#If number of observations fails the nmin constraint or no split could be found
#then return a leaf node data frame
if(length(y) < nmin || is.na(split <- bestsplit(x,y,minleaf,nfeat))){
node <- data.frame(idNode, NA, NA, NA, NA,round(sum(y)/length(y)))
names(node) <- c("node", "leftChild", "rightChild", "feature","splitValue", "label")
return(node)
}
# If valid split if found, create the left node and right node
toLeft <- x[,split$feature] <= split$val
toRight <- !toLeft
leftNode <- x[toLeft,]
rightNode <- x[toRight,]
# Recursively construct the tree
leftChild <- tree.grow1(leftNode, y[toLeft], nmin, minleaf, nfeat)
rightChild <- tree.grow1(rightNode, y[toRight], nmin, minleaf, nfeat)
# Add labels to the matrix so we can access them easier
names(leftChild) <- c("node", "leftChild", "rightChild", "feature","splitValue","label")
names(rightChild) <- c("node", "leftChild", "rightChild", "feature","splitValue","label")
# Construct the root node
tree <- data.frame(idNode, leftChild[1,1], rightChild[1,1],split$feature, split$val,round(sum(y)/length(y)))
names(tree) <- c("node", "leftChild", "rightChild", "feature","splitValue", "label")
# Combine the branches to one tree and return
return(rbind(rbind(tree, leftChild), rightChild))
}
tree.grow(indian.x, y, 5,20,8)
tree.grow(indian.x, y, 5,20,8)
tree.grow(indian.x, y, 5,20,8)
tree.grow(indian.x, y, 5,20,8)
rm(nodeIdx)
tree.grow(indian.x, y, 5,20,8)
tree.grow(indian.x, y, 5,20,8)
tr <- tree.grow(indian.x, y, 5,20,8)
tree.classify(indian.x, tr)
pred <- tree.classify(indian.x, tr)
table(pred, y)
pima <- read.csv(B:/School/Master/Data Mining/INFOMDM/Assignment1/Pima/pimaset.txt)
pima <- read.csv("B:/School/Master/Data Mining/INFOMDM/Assignment1/Pima/pimaset.txt")
pima.x <- pima[,1:8]
pima.x
pima.y <- pima[,9]
tr <- tree.grow(pima.x, pima.y, 5,20,8)
pred <- tree.classify(pima.x, tr)
table(pred, y)
length(y)
length(pred)
444+56+54+214
444+56+54+214
pima <- read.csv("B:/School/Master/Data Mining/INFOMDM/Assignment1/Pima/pimaset.txt")
pima.x
pima.x <- pima[,1:8]
pima.y <- pima[,9]
tr <- tree.grow(pima.x, pima.y, 5,20,8)
pred <- tree.classify(pima.x, tr)
table(pred, y)
tr <- tree.grow(pima.x, pima.y, 20,5,8)
pred <- tree.classify(pima.x, tr)
table(pred, y)
pima <- read.csv("B:/School/Master/Data Mining/INFOMDM/Assignment1/Pima/pimaset.txt")
pima.x <- pima[,1:8]
pima.y <- pima[,9]
tr <- tree.grow(pima.x, pima.y, 20,5,8)
pred <- tree.classify(pima.x, tr)
table(pred, y)
table(y, pred)
pima <- read.csv("B:/School/Master/Data Mining/INFOMDM/Assignment1/Pima/pimaset.txt")
tr <- tree.grow(pima.x, pima.y, 20,5,8)
# tree.grow - recursive function that grows a single tree on a given training set
# params:
# x, a data matrix containing the attribute values. Each row contains the attribute values of one training example
# y, vector of class labels (binary) with no missing values
# nmin, min number of observations a node must contain for it to be allowed to split
# minleaf, min number of observations required for a leaf node
# nfeat, number of features that should be considered for each split
# returns: a tree data frame for predicting new cases
tree.grow <- function(x,y,nmin,minleaf,nfeat){
nodeIdx <<- 0
tree.grow1(x,y,nmin,minleaf,nfeat)
}
tree.grow1 <- function(x,y,nmin,minleaf,nfeat){
# Set the node incrementer
idNode <- nodeIdx
nodeIdx <<- nodeIdx + 1
#If number of observations fails the nmin constraint or no split could be found
#then return a leaf node data frame
if(length(y) < nmin || is.na(split <- bestsplit(x,y,minleaf,nfeat))){
node <- data.frame(idNode, NA, NA, NA, NA,round(sum(y)/length(y)))
names(node) <- c("node", "leftChild", "rightChild", "feature","splitValue", "label")
return(node)
}
# If valid split if found, create the left node and right node
toLeft <- x[,split$feature] <= split$val
toRight <- !toLeft
leftNode <- x[toLeft,]
rightNode <- x[toRight,]
# Recursively construct the tree
leftChild <- tree.grow1(leftNode, y[toLeft], nmin, minleaf, nfeat)
rightChild <- tree.grow1(rightNode, y[toRight], nmin, minleaf, nfeat)
# Add labels to the matrix so we can access them easier
names(leftChild) <- c("node", "leftChild", "rightChild", "feature","splitValue","label")
names(rightChild) <- c("node", "leftChild", "rightChild", "feature","splitValue","label")
# Construct the root node
tree <- data.frame(idNode, leftChild[1,1], rightChild[1,1],split$feature, split$val,round(sum(y)/length(y)))
names(tree) <- c("node", "leftChild", "rightChild", "feature","splitValue", "label")
# Combine the branches to one tree and return
return(rbind(rbind(tree, leftChild), rightChild))
}
# tree.classify - classifies test set using the classification tree
# x, a data matrix containing the attribute values of the cases for which predictions are required
# tr, tree object created with tree.grow
# returns: y, vector of predicted class labels for the cases in x
tree.classify <- function(x, tr){
outLabels <- c(1:nrow(x))
#for each observation in the test set
for (i in 1:nrow(x)){
currNode <- tr[1,]
#continue down the tree until a leaf node is found
while (!is.na(currNode$leftChild)){
if (x[i,currNode$feature]<=currNode$splitValue){currNode<- tr[currNode$leftChild+1,]}
else {currNode<- tr[currNode$rightChild+1,]}
}
#assign the leaf node label to the current observation
outLabels[i] <- currNode$label
}
return(outLabels)
}
# tree.grow.bag - Executes tree.grow for m bootstrap samples.
# x,y,nmin,minleaf,nfeat as before. m number of bootstrap samples
# Returns: A list of length m containing m trees
tree.grow.bag <- function(x, y, nmin, minleaf, nfeat, m){
trees <- list()
for (i in c(1:m)){
#reset counter
nodeIdx <<- 0
#take x samples from training set with replacement and perform tree.grow
sample <- sample(nrow(x),nrow(x), replace=TRUE)
tr <- tree.grow(x[sample,],y[sample],nmin,minleaf,nfeat)
trees[[i]] <- tr
}
return (trees)
}
# tree.classify.bag - classifies test set by the majority label assigned by bagged tree
# treeList, list of trees
# x, data matrix for which the predictions are required
# returns: A vector y, where y[i] contains the predicted class label for row i of x
tree.classify.bag <- function(x, treeList)
{
vectorOut = integer(nrow(x))
#for each tree in the bagged tree
for(tree in treeList){
#perform tree.classify with the test set
labels <- tree.classify(x,tree)
vectorOut <- vectorOut + labels
}
#round average of labels to the nearest integer, which results in the labels 0 or 1 (majority vote)
resultingLabels <- as.integer(round(vectorOut / length(treeList)))
return(resultingLabels)
}
#impurityGini - calculates the impurity of a node using Gini index
# y, vector of labels observed
# returns: an integer equal to the impurity of the node
impurityGini <- function(y){
p1 <- sum(y)/length(y)
return(p1*(1-p1))
}
# bestsplit - finds the best split feature and splitvalue out of nfeat features
# matrix, atrribute values of training data
# y, vector of labels corresponding to observations of training data
# minleaf, integer equal to the minimum number of observations required for a leaf node
# nfeat, number of features to be sampled from the total number of features
bestsplit <- function(matrix,y, minleaf,nfeat){
bestSplit.impurity <- .Machine$integer.max
splitSuccesfull = FALSE;
#sample nfeat features without replacement
selectedFeats <- sample(c(1:ncol(matrix)), nfeat)
for (i in selectedFeats){
x <- matrix[,i]
uniqueValues <- sort(unique(x))
#find splitpoints between all unique attribute values
splitpoints <- (uniqueValues[1:length(uniqueValues)-1]+uniqueValues[2:length(uniqueValues)])/2
for (splitVal in splitpoints) {
#perform split and check minleaf constraints
split.left <- y[x <= splitVal]
split.right <- y[x > splitVal]
# If the split exceeds the min leaf constraint we do not consider this split
if (length(split.left)<minleaf || length(split.right)<minleaf) {
next
}
#save split if it has the lowest impurity so far
currImpurity <- length(split.left)*impurityGini(split.left) + length(split.right)*impurityGini(split.right)
if (currImpurity < bestSplit.impurity){
splitSuccesfull=TRUE
bestSplit.feature<-i
bestSplit.impurity <- currImpurity
bestSplit.value <- splitVal
}
}
}
#if no succesfull split was found return NA, otherwise return split
if (!splitSuccesfull){return(NA)}
return(list("feature"=bestSplit.feature, "val"=bestSplit.value))
}
tr <- tree.grow(pima.x, pima.y, 20,5,8)
pima.y <- pima[,9]
pima.x <- pima[,1:8]
tr <- tree.grow(pima.x, pima.y, 20,5,8)
tr
pred <- tree.classify(pima.x)
pred <- tree.classify(pima.x, tr)
table(pred, indian.y)
table(pred, pima.y)
citation(package = "e1071")
citation(package = "class")
citation(package = "nnet")
citation(package = "caret")
citation(package = "MASS")
citation("datasets")
citation("mnist")
install.packages("glmnet")
citation("glmnet")
maleIQ <- c(0.83, 0.54, 0.08, 0.92, 0.67, 0.17, 0.25, 0.83, 0.42)
femaleIQ <- c(0.58, 0.17, 0.58, 0.33, 0.42, 0.42, 0.21)
aov?
?aov
setwd(B:\Projects\MasterThesis\music-analysis)
setwd("B://Projects//MasterThesis//music-analysis")
install.package(tuneR)
install.packages(tuneR)
install.packages("tuneR")
library(tuneR)
setwd("B://Projects//MasterThesis//music-analysis")
readMidi("chopin-no2.midi")
readMidi("chopin-no2.mid")
song <- readMidi("chopin-no2.mid")
setwd(B:\Projects\MasterThesis\music-analysis)
str(song)
View(song)
midi_notes <- read.csv("midi-notes.csv")
View(midi_notes)
note_off <- song[which(song$event=="Note on")]
note_off
View(note_off)
note_off <- song[which(song$event=="Note on"),]
note_off
song$event == "Note On"
note_off <- song[which(song$event=="Note On"),]
note_on <- song[which(song$event=="Note On"),]
note_on$parameter1
midi-notes[note_on$parameter1]
midi_notes[note_on$parameter1]
midi_notes$Note.names..English.[note_on$parameter1]
note_on$track == 1
note_on[which(note_on$track == 1)]
note_on[which(note_on$track == 1),]
#Get events from tracks
events_track1 <- note_on[which(note_on$track == 1),]
events_track2 <- note_on[which(note_on$track == 2),]
# Get notes from the events as a sequence
notes_track1 <- midi_notes$Note.names..English.[events_track1$parameter1]
# Get notes from the events as a sequence
notes_track1 <- midi_notes$Note.names..English.[events_track1$parameter1]
notes_track1
notes_track2 <- midi_notes$Note.names..English.[events_track1$parameter1]
notes_track2 <- midi_notes$Note.names..English.[events_track2$parameter1]
notes_track2
midi_notes$Note.names..English
events_track1$parameter1
midi_notes$Note.names..English[which(midi_notes$midi.note.number == events_track1$parameter1)]
which(midi_notes$midi.note.number == events_track1$parameter1)
events_track1$parameter1
midi_notes$midi.note.number == events_track1$parameter1
midi_notes$midi.note.number
midi_notes$MIDI.note.number
which(midi_notes$MIDI.note.number == events_track1$parameter1)
which(events_track1$parameter1 == midi_notes$MIDI.note.number)
(events_track1$parameter1 == midi_notes$MIDI.note.number)
events_track1$parameter1
midi_notes[,midi_notes$MIDI.note.number == events_track1$parameter1]
midi_notes[midi_notes$MIDI.note.number == events_track1$parameter1,]
key <- data.frame(vector = events_track1$parameter1)
key
match?
?match
match(key, midi_notes$MIDI.note.number)
note_midi_mapping ,_ key[match(midi_notes$MIDI.note.number, key), 'Note']
note_midi_mapping _ key[match(midi_notes$MIDI.note.number, key), 'Note']
note_midi_mapping <- key[match(midi_notes$MIDI.note.number, key), 'Note']
note_midi_mapping
match(midi_notes$MIDI.note.number, key)
match(key,midi_notes$MIDI.note.number)
key
midi_notes$MIDI.note.number
midi_notes$MIDI.note.number
key
key$vector
midi_notes$MIDI.note.number
midi_notes$MIDI.note.number == 1
key <- data.frame(events = events_track1$parameter1, mat=c('a','b','c'))
key <- data.frame(events = midi_notes$MIDI.note.number)
data <- data.frame(events_track1$parameter1)
data$vector1 <- key[match(data$events_track1.parameter1, key$events), 'notes']
data
data$vector1 <- key[match(data$events_track1.parameter1, key$events), 'notes']
data$vector1
key[match(data$events_track1.parameter1, key$events), 'notes']
match(data$events_track1.parameter1, key$events)
key$events[match(data$events_track1.parameter1, key$events),]
midi_notes[match(data$events_track1.parameter1, key$events),]
midi_notes[match(data$events_track1.parameter1, key$events),]$
midi_notes[match(data$events_track1.parameter1, key$events),]$Note.names..English.
notes_track1
midi_notes[match(data$events_track1.parameter1, key$events),]$Note.names..English.
# Get notes from the events as a sequence
notes_track1 <- midi_notes[match(data$events_track1.parameter1, key$events),]$Note.names..English.
notes_track2 <- midi_notes[match(data$events_track2.parameter1, key$events),]$Note.names..English.
notes_track1
notes_track1
song <- readMidi("chopin-no2.mid")
midi_notes <- read.csv("midi-notes.csv")
# Map events to midi notes
key <- midi_notes$MIDI.note.number
data <- data.frame(events_track1$parameter1)
# Get notes from the events as a sequence
notes_track1 <- midi_notes[match(data$events_track1.parameter1, key$events),]$Note.names..English.
notes_track2 <- midi_notes[match(data$events_track2.parameter1, key$events),]$Note.names..English.
# Map events to midi notes
key <- midi_notes$MIDI.note.number
data <- data.frame(events_track1$parameter1)
midi_notes
data <- data.frame(events = events_track1$parameter1)
# Get notes from the events as a sequence
notes_track1 <- midi_notes[match(data$events_track1.parameter1, key$events),]$Note.names..English.
# Map events to midi notes
key <- midi_notes$MIDI.note.number
data <- data.frame(events_track1$parameter1)
key
data
midi_notes[match(data$events_track1.parameter1, key$events),]$Note.names..English.
midi_notes[match(data$events_track1.parameter1, key$events),]
midi_notes[match(data$events_track1.parameter1, key),]
# Get notes from the events as a sequence
notes_track1 <- midi_notes[match(data$events_track1.parameter1, key),]$Note.names..English.
notes_track2 <- midi_notes[match(data$events_track2.parameter1, key),]$Note.names..English.
notes_track1
frequency(notes_track1)
summary(notes_track1)
list(midi_notes$Note.names..English., midi_notes$Note.names..English.)
matrix_names <- list(midi_notes$Note.names..English., midi_notes$Note.names..English.)
matrix_names["G#9", "G#9"]
matrix_names <- list(c(midi_notes$Note.names..English.), c(midi_notes$Note.names..English.))
matrix_names["G#9", "G#9"]
View(matrix_names)
View(matrix_names)
transition_matrix <- matrix()
dimnames(transition_matrix) <- list(c(midi_notes$Note.names..English.), c(midi_notes$Note.names..English.))
midi_notes <- read.csv("midi-notes.csv")
# Get all note on events
note_on <- song[which(song$event=="Note On"),]
#Get events from tracks
events_track1 <- note_on[which(note_on$track == 1),]
events_track2 <- note_on[which(note_on$track == 2),]
# Map events to midi notes
key <- midi_notes$MIDI.note.number
data <- data.frame(events_track1$parameter1)
# Get notes from the events as a sequence
notes_track1 <- midi_notes[match(data$events_track1.parameter1, key),]$Note.names..English.
notes_track2 <- midi_notes[match(data$events_track2.parameter1, key),]$Note.names..English.
transition_matrix <- matrix(, nrow=midi_notes$notes.length, ncol =midi_notes$notes.length )
midi_notes$notes.length
length(midi_notes$notes)
transition_matrix <- matrix(, length(nrow=midi_notes$notes), ncol =length(midi_notes$notes.length ))
transition_matrix <- matrix(, nrow=length(midi_notes$notes), ncol =length(midi_notes$notes.length))
transition_matrix
dimnames(transition_matrix) <- list(c(midi_notes$notes), c(midi_notes$notes))
dimnames(transition_matrix) <- list(midi_notes$notes, midi_notes$notes)
transition_matrix <- matrix(, nrow=length(midi_notes$notes), ncol =length(midi_notes$notes.length))
length(midi_notes$notes)
transition_matrix <- matrix(1:11664, nrow=length(midi_notes$notes), ncol =length(midi_notes$notes.length))
transition_matrix <- matrix(1:11664, nrow=length(midi_notes$notes), ncol =length(midi_notes$notes)
)
View(transition_matrix)
dimnames(transition_matrix) <- list(midi_notes$notes, midi_notes$notes)
View(transition_matrix)
transition_matrix <- matrix(, nrow=length(midi_notes$notes), ncol =length(midi_notes$notes)
)
notes_track1[1]
notes_track1[2]
notes_track1
# Get notes from the events as a sequence
notes_track1 <- midi_notes[match(data$events_track1.parameter1, key),]$Note.names..English.
notes_track2 <- midi_notes[match(data$events_track2.parameter1, key),]$Note.names..English.
notes_track1
# Map events to midi notes
key <- midi_notes$number
data <- data.frame(events_track1$parameter1)
# Get notes from the events as a sequence
notes_track1 <- midi_notes[match(data$events_track1.parameter1, key),]$notes
notes_track2 <- midi_notes[match(data$events_track2.parameter1, key),]$notes.
notes_track1[2]
#Initialize transition matrix
#TODO: Add initial note, so start note without any posterior
transition_matrix <- matrix(rep(0,length(midi_notes)*length(midi_notes)), nrow=length(midi_notes$notes), ncol =length(midi_notes$notes))
for(i <- length(notes_track1)){
if(i == 1){continue;}
prev <- notes_track1[i-1]
curr <- notes_track[i]
transition_matrix[curr,prev] <- transition_matrix[curr,prev] + 1
}
for(i in length(notes_track1)){
if(i == 1){continue;}
prev <- notes_track1[i-1]
curr <- notes_track[i]
transition_matrix[curr,prev] <- transition_matrix[curr,prev] + 1
}
for(i in length(notes_track1)){
if(i == 1){continue;}
prev <- notes_track1[i-1]
curr <- notes_track1[i]
transition_matrix[curr,prev] <- transition_matrix[curr,prev] + 1
}
View(transition_matrix)
#Add dimension names
dimnames(transition_matrix) <- list(midi_notes$notes, midi_notes$notes)
for(i in length(notes_track1)){
if(i == 1){continue;}
prev <- notes_track1[i-1]
curr <- notes_track1[i]
transition_matrix[curr,prev] <- transition_matrix[curr,prev] + 1
}
transition_matrix["G4", "G4"]
transition_matrix["G4", "G4"] <- 2
transition_matrix["G4", "G4"]
View(transition_matrix)
notes_track[2]
notes_track1[2]
note1_test <- notes_track1[2]
note2_test <- notes_track1[1]
note1_test
note2_test <- notes_track1[1,]
note2_test <- notes_track1[,1]
note2_test <- notes_track1[1]
transition_matrix[note1_test, note2_test]
debugSource('B:/Projects/MasterThesis/music-analysis/model_training.R')
transition_matrix[note1_test, note2_test] <- transition_matrix[note1_test, note2_test] +1
transition_matrix[note1_test, note2_test]
transition_matrix[note1_test, note2_test]
length(notes_track1)
debugSource('B:/Projects/MasterThesis/music-analysis/model_training.R')
for(i in 1:length(notes_track1)){
if(i == 1){continue;}
prev <- notes_track1[i-1]
curr <- notes_track1[i]
transition_matrix[curr,prev] <- transition_matrix[curr,prev] + 1
}
for(i in 1:length(notes_track1)){
if(i == 1){next;}
prev <- notes_track1[i-1]
curr <- notes_track1[i]
transition_matrix[curr,prev] <- transition_matrix[curr,prev] + 1
}
View(transition_matrix)
#Initialize frequency vector
track1_note_frequency <- factor(levels = midi_notes$notes)
#Initialize frequency vector
track1_note_frequency <- factor(x = rep(0, length(midi_notes)),levels = midi_notes$notes)
for(i in 1:length(notes_track1)){
curr <- notes_track1[i]
track1_note_frequency[curr] <- track1_note_frequency[curr] + 1
}
#Initialize frequency vector
track1_note_frequency <- factor(x = rep(0, length(midi_notes)),levels = midi_notes$notes)
#Initialize frequency vector
track1_note_frequency["G#9"] <- 2
#Initialize frequency vector
track1_note_frequency
#Initialize frequency vector
track1_note_frequency <- matrix(x = rep(0, length(midi_notes)), ncol=length(midi_notes))
#Initialize frequency vector
track1_note_frequency <- matrix(x = rep(0, length(midi_notes)), nrow=1, ncol=length(midi_notes))
#Initialize frequency vector
track1_note_frequency <- matrix(rep(0, length(midi_notes)), nrow=1, ncol=length(midi_notes))
dimnames(track1_note_frequency) <- midi_notes$notes
dimnames(track1_note_frequency) <- list(midi_notes$notes)
#Initialize frequency vector
track1_note_frequency <- data.frame(rep(0, length(midi_notes)), nrow=1, ncol=length(midi_notes))
dimnames(track1_note_frequency) <- list(midi_notes$notes)
track1_note_frequency
