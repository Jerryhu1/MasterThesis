#perform tree.classify with the test set
labels <- tree.classify(x,tree)
vectorOut <- vectorOut + labels
}
#round average of labels to the nearest integer, which results in the labels 0 or 1 (majority vote)
resultingLabels <- as.integer(round(vectorOut / length(treeList)))
return(resultingLabels)
}
#impurityGini - calculates the impurity of a node using Gini index
# y, vector of labels observed
# returns: an integer equal to the impurity of the node
impurityGini <- function(y){
p1 <- sum(y)/length(y)
return(p1*(1-p1))
}
# bestsplit - finds the best split feature and splitvalue out of nfeat features
# matrix, atrribute values of training data
# y, vector of labels corresponding to observations of training data
# minleaf, integer equal to the minimum number of observations required for a leaf node
# nfeat, number of features to be sampled from the total number of features
bestsplit <- function(matrix,y, minleaf,nfeat){
bestSplit.impurity <- .Machine$integer.max
splitSuccesfull = FALSE;
#sample nfeat features without replacement
selectedFeats <- sample(c(1:ncol(matrix)), nfeat)
for (i in selectedFeats){
x <- matrix[,i]
uniqueValues <- sort(unique(x))
#find splitpoints between all unique attribute values
splitpoints <- (uniqueValues[1:length(uniqueValues)-1]+uniqueValues[2:length(uniqueValues)])/2
for (splitVal in splitpoints) {
#perform split and check minleaf constraints
split.left <- y[x <= splitVal]
split.right <- y[x > splitVal]
# If the split exceeds the min leaf constraint we do not consider this split
if (length(split.left)<minleaf || length(split.right)<minleaf) {
next
}
#save split if it has the lowest impurity so far
currImpurity <- length(split.left)*impurityGini(split.left) + length(split.right)*impurityGini(split.right)
if (currImpurity < bestSplit.impurity){
splitSuccesfull=TRUE
bestSplit.feature<-i
bestSplit.impurity <- currImpurity
bestSplit.value <- splitVal
}
}
}
#if no succesfull split was found return NA, otherwise return split
if (!splitSuccesfull){return(NA)}
return(list("feature"=bestSplit.feature, "val"=bestSplit.value))
}
tr <- tree.grow(pima.x, pima.y, 20,5,8)
pima.y <- pima[,9]
pima.x <- pima[,1:8]
tr <- tree.grow(pima.x, pima.y, 20,5,8)
tr
pred <- tree.classify(pima.x)
pred <- tree.classify(pima.x, tr)
table(pred, indian.y)
table(pred, pima.y)
citation(package = "e1071")
citation(package = "class")
citation(package = "nnet")
citation(package = "caret")
citation(package = "MASS")
citation("datasets")
citation("mnist")
install.packages("glmnet")
citation("glmnet")
maleIQ <- c(0.83, 0.54, 0.08, 0.92, 0.67, 0.17, 0.25, 0.83, 0.42)
femaleIQ <- c(0.58, 0.17, 0.58, 0.33, 0.42, 0.42, 0.21)
aov?
?aov
View(getAspectRatio)
#Trains a transition matrix given a corpus and all possible notes.
train.transitionMatrix <- function(corpus, possibleNotes){
transition_matrix <- matrix(rep(0,length(possibleNotes)*length(possibleNotes)), nrow=length(possibleNotes), ncol=length(possibleNotes))
dimnames(transition_matrix) <- list(possibleNotes, possibleNotes)
frequency_vector <- matrix(rep(0, length(possibleNotes)), nrow=1, ncol=length(possibleNotes))
for(i in 1:length(corpus)){
curr <- corpus[[i]]
#Take the notes of current song and get frequency vector
frequency_vector <- frequencyVector(frequency_vector, possibleNotes, notes = curr)
#Update the transition matrix by this current song
transition_matrix <- transitionMatrix(transition_matrix, possibleNotes, curr)
}
# Divide by frequency vector
transition_matrix <- t(t(transition_matrix) / frequency_vector[1,])
transition_matrix[is.nan(transition_matrix)] <- 0
return(transition_matrix)
}
#Creates or updates the transition matrix given its 1-gram frequency matrix, all possible notes vector and the given notes vector
transitionMatrix <- function(transition_matrix, possibleNotes, notes){
#Initialize transition matrix
#TODO: Add initial note, so start note without any posterior
if(is.null(transition_matrix)){
transition_matrix <- matrix(rep(0,length(possibleNotes)*length(possibleNotes)), nrow=length(possibleNotes), ncol=length(possibleNotes))
#Add dimension names
dimnames(transition_matrix) <- list(possibleNotes, possibleNotes)
}
for(i in 1:length(notes)){
if(i == 1){next;}
prev <- notes[i-1]
curr <- notes[i]
transition_matrix[curr,prev] <- transition_matrix[curr,prev] + 1
}
#Divide by univariate frequency to get probabilities
#transition_matrix <- t(t(transition_matrix) / frequencyVector[1,])
return(transition_matrix)
}
#Creates or updates a frequency vector given the possible notes and sequence of notes
frequencyVector<- function(note_frequency, possibleNotes, notes){
if(is.null(note_frequency)){
#Initialize frequency vector
note_frequency <- matrix(rep(0, length(possibleNotes)), nrow=1, ncol=length(possibleNotes))
#Set dimension names by the possible notes vector
colnames(note_frequency) <- possibleNotes
#Fill up frequency vector
for(i in 1:length(notes)){
curr <- notes[i]
note_frequency[curr] <- note_frequency[curr] + 1
}
return(note_frequency)
}
#Fill up frequency vector
for(i in 1:length(notes)){
curr <- notes[i]
note_frequency[curr] <- note_frequency[curr] + 1
}
return(note_frequency)
}
# Read all files in given folder relative to the workspace
getCorpus <- function(folderName){
files <- list.files(folderName, pattern="*.mid", full.names=TRUE)
return(lapply(files, readMidi))
}
#Gets the notes for a specific item
getNotesForItem <- function(item, midi_notes){
# Get all note on events
note_on <- item[which(item$event=="Note On"),]
# Get notes from the events as a sequence
notes <- midi_notes[match(note_on$parameter1, key),]$notes
return(notes)
}
install.packages("tuneR")
library(tuneR)
setwd("B://School//Master//Thesis//MasterThesis//music-analysis")
getCorpus("midi")
corpus <- Last.value
corpus <- getCorpus("midi")
midi_notes <- read.csv("midi-notes.csv")
train.transitionMatrix(corpus, midi_notes)
getNotesF
corpus[1,]
corpus[1]
getNotesForItem(corpus[1], midi_notes)
corpus[1]
corpus[,1]
corpus[0,]
getNotesForItem(corpus[1], midi_notes)
corpus[1][which(corpus[1]$event == "Note on")]
corpus[1][which(corpus[1]$event == "Note On")]
which(corpus[1]$event == "Note On")
corpus[1]
corpus[1]$event
corpus[1].event
View(corpus)
corpus[[1]]$event
getNotesForItem(corpus[[1]], midi_notes)
#Gets the notes for a specific item
getNotesForItem <- function(item, midi_notes){
# Get all note on events
note_on <- item[which(item$event=="Note On"),]
key <- midi_notes$number
# Get notes from the events as a sequence
notes <- midi_notes[match(note_on$parameter1, key),]$notes
return(notes)
}
getNotesForItem(corpus[[1]], midi_notes)
lapply(corpus, getNotesForItem, midi_notes = midi_notes)
# Runs the model training given corpus folder
run <- function(folder){
midi_notes <- read.csv("midi-notes.csv")
corpus <- getCorpus(folder)
corpusNotes <- getNotesForCorpus(corpus, midi_notes)
return (train.transitionMatrix(corpusNotes, midi_notes))
}
#Trains a transition matrix given a corpus and all possible notes.
train.transitionMatrix <- function(corpus, possibleNotes){
transition_matrix <- matrix(rep(0,length(possibleNotes)*length(possibleNotes)), nrow=length(possibleNotes), ncol=length(possibleNotes))
dimnames(transition_matrix) <- list(possibleNotes, possibleNotes)
frequency_vector <- matrix(rep(0, length(possibleNotes)), nrow=1, ncol=length(possibleNotes))
for(i in 1:length(corpus)){
curr <- corpus[[i]]
#Take the notes of current song and get frequency vector
frequency_vector <- frequencyVector(frequency_vector, possibleNotes, notes = curr)
#Update the transition matrix by this current song
transition_matrix <- transitionMatrix(transition_matrix, possibleNotes, curr)
}
# Divide by frequency vector
transition_matrix <- t(t(transition_matrix) / frequency_vector[1,])
transition_matrix[is.nan(transition_matrix)] <- 0
return(transition_matrix)
}
#Creates or updates the transition matrix given its 1-gram frequency matrix, all possible notes vector and the given notes vector
transitionMatrix <- function(transition_matrix, possibleNotes, notes){
#Initialize transition matrix
#TODO: Add initial note, so start note without any posterior
if(is.null(transition_matrix)){
transition_matrix <- matrix(rep(0,length(possibleNotes)*length(possibleNotes)), nrow=length(possibleNotes), ncol=length(possibleNotes))
#Add dimension names
dimnames(transition_matrix) <- list(possibleNotes, possibleNotes)
}
for(i in 1:length(notes)){
if(i == 1){next;}
prev <- notes[i-1]
curr <- notes[i]
transition_matrix[curr,prev] <- transition_matrix[curr,prev] + 1
}
#Divide by univariate frequency to get probabilities
#transition_matrix <- t(t(transition_matrix) / frequencyVector[1,])
return(transition_matrix)
}
#Creates or updates a frequency vector given the possible notes and sequence of notes
frequencyVector<- function(note_frequency, possibleNotes, notes){
if(is.null(note_frequency)){
#Initialize frequency vector
note_frequency <- matrix(rep(0, length(possibleNotes)), nrow=1, ncol=length(possibleNotes))
#Set dimension names by the possible notes vector
colnames(note_frequency) <- possibleNotes
#Fill up frequency vector
for(i in 1:length(notes)){
curr <- notes[i]
note_frequency[curr] <- note_frequency[curr] + 1
}
return(note_frequency)
}
#Fill up frequency vector
for(i in 1:length(notes)){
curr <- notes[i]
note_frequency[curr] <- note_frequency[curr] + 1
}
return(note_frequency)
}
# Read all files in given folder relative to the workspace
getCorpus <- function(folderName){
files <- list.files(folderName, pattern="*.mid", full.names=TRUE)
return(lapply(files, readMidi))
}
#Gets all notes from the corpus as multiple lists
getNotesForCorpus <- function(corpus, midi_notes){
return (lapply(corpus, getNotesForItem, midi_notes = midi_notes))
}
#Gets the notes for a specific item
getNotesForItem <- function(item, midi_notes){
# Get all note on events
note_on <- item[which(item$event=="Note On"),]
key <- midi_notes$number
# Get notes from the events as a sequence
notes <- midi_notes[match(note_on$parameter1, key),]$notes
return(notes)
}
run <- function(corpus){
midi_notes <- read.csv("midi-notes.csv")
corpusNotes <- getNotesForCorpus(corpus, midi_notes)
return (train.transitionMatrix(corpusNotes, midi_notes))
}
run(corpus)
getNotesForCorpus(corpus, midi_notes)
corpusNotes <- getNotesForCorpus(corpus, midi_notes)
train.transitionMatrix(corpusNotes, midi_notes)
train.transitionMatrix(corpus, midi_notes)
#Gets all notes from the corpus as multiple lists
getNotesForCorpus <- function(corpus, midi_notes){
return (lapply(corpus, function(c) return(getNotesForItem(c, midi_notes))))
}
corpus_notes <- getNotesForCorpus(corpus, midi_notes)
train.transitionMatrix(corpus_notes, midi_notes)
possibleNotes <- midi_notes$notes
train.transitionMatrix(corpus_notes, possibleNotes)
transition_matrix <- train.transitionMatrix(corpus_notes, possibleNotes)
View(transition_matrix)
transition_matrix[1:2]
transition_matrix[1:2, 1:2]
song <- readMidi("chopin-no2.mid")
song <- readMidi("midi//chopin-no2.mid")
# Get all note on events
note_on <- song[which(song$event=="Note On"),]
# Map events to midi notes
key <- midi_notes$number
#Get events from tracks
events_track1 <- note_on[which(note_on$track == 1),]
data <- data.frame(events_track1$parameter1)
# Get notes from the events as a sequence
notes_track1 <- midi_notes[match(data$events_track1.parameter1, key),]$notes
notes_track2 <- midi_notes[match(data$events_track2.parameter1, key),]$notes
#Initialize frequency vector
track1_note_frequency <- matrix(rep(0, length(midi_notes)), nrow=1, ncol=length(midi_notes$notes))
colnames(track1_note_frequency) <- midi_notes$notes
#Fill up frequency vector
for(i in 1:length(notes_track1)){
curr <- notes_track1[i]
track1_note_frequency[curr] <- track1_note_frequency[curr] + 1
}
#Initialize transition matrix
#TODO: Add initial note, so start note without any posterior
transition_matrix <- matrix(rep(0,length(midi_notes)*length(midi_notes)), nrow=length(midi_notes$notes), ncol =length(midi_notes$notes))
#Add dimension names
dimnames(transition_matrix) <- list(midi_notes$notes, midi_notes$notes)
View(transition_matrix)
View(events_track1)
View(note_on)
notes_track1
notes_track2
transitionMatrix(NULL, possibleNotes, notes_track2)
transition_matrix <- transitionMatrix(NULL, possibleNotes, notes_track2)
View(transition_matrix)
transition_matrix[G#3, G#3] <- 2
transition_matrix[G#3, G#3] = 3
#Fill up frequency vector
for(i in 1:length(notes_track1)){
curr <- notes_track1[i]
track1_note_frequency[curr] <- track1_note_frequency[curr] + 1
}
transition_matrix[G#3, G#3] = 3
transition_matrix[G#3, G#3]
transition_matrix
transition_matrix[G#3, G#3]
transitionMatrix(NULL, possibleNotes, notes_track1)
notes_track12
notes_track1
transition_matrix <- transitionMatrix(NULL, possibleNotes, notes_track1)
transition_matrix[A#4, G5]
#Initialize transition matrix
#TODO: Add initial note, so start note without any posterior
transition_matrix <- matrix(rep(0,length(midi_notes)*length(midi_notes)), nrow=length(midi_notes$notes), ncol =length(midi_notes$notes))
transition_matrix_test <- transitionMatrix(NULL, possibleNotes, notes_track1)
transition_matrix_test
transition_matrix_test[1,1]
transition_matrix_test[G#1,G#3]
transition_matrix_test["G#1","G#3"]
transition_matrix_test["G5","F5"]
View(transition_matrix)
View(transition_matrix_test)
#Creates or updates the transition matrix given its 1-gram frequency matrix, all possible notes vector and the given notes vector
transitionMatrix <- function(transition_matrix, possibleNotes, notes){
#Initialize transition matrix
#TODO: Add initial note, so start note without any posterior
if(is.null(transition_matrix)){
transition_matrix <- matrix(rep(0,length(possibleNotes)*length(possibleNotes)), nrow=length(possibleNotes), ncol=length(possibleNotes))
#Add dimension names
dimnames(transition_matrix) <- list(possibleNotes, possibleNotes)
}
for(i in 1:length(notes)){
if(i == 1){next;}
prev <- notes[i-1]
curr <- notes[i]
transition_matrix[prev,curr] <- transition_matrix[curr,prev] + 1
}
#Divide by univariate frequency to get probabilities
#transition_matrix <- t(t(transition_matrix) / frequencyVector[1,])
return(transition_matrix)
}
transitionMatrix(NULL, possibleNotes, notes_track1)
transition_matrix_test <- transitionMatrix(NULL, possibleNotes, notes_track1)
View(transition_matrix_test)
notes_track1
debugSource('B:/School/Master/Thesis/MasterThesis/music-analysis/model_training.R')
install.packages("tuneR")
transition_matrix_test <- transitionMatrix(NULL, possibleNotes, notes_track1)
debugSource('B:/School/Master/Thesis/MasterThesis/music-analysis/model_training.R')
install.packages("tuneR")
install.packages("tuneR")
debugSource('B:/School/Master/Thesis/MasterThesis/music-analysis/model_training.R')
install.packages("tuneR")
transition_matrix_test <- transitionMatrix(NULL, possibleNotes, notes_track1)
curr
prev
View(transition_matrix)
transition_matrix["G5", "F5"]
transition_matrix["G5", "F5"] <- 1
transition_matrix["G5", "F5"]
transitionMatrix <- function(transition_matrix, possibleNotes, notes){
#Initialize transition matrix
#TODO: Add initial note, so start note without any posterior
if(is.null(transition_matrix)){
transition_matrix <- matrix(rep(0,length(possibleNotes)*length(possibleNotes)), nrow=length(possibleNotes), ncol=length(possibleNotes))
#Add dimension names
dimnames(transition_matrix) <- list(possibleNotes, possibleNotes)
}
for(i in 1:length(notes)){
if(i == 1){next;}
prev <- notes[i-1]
curr <- notes[i]
transition_matrix[prev,curr] <- transition_matrix[prev,curr] + 1
}
#Divide by univariate frequency to get probabilities
#transition_matrix <- t(t(transition_matrix) / frequencyVector[1,])
return(transition_matrix)
}
transition_matrix_test <- transitionMatrix(NULL, possibleNotes, notes_track1)
transition_matrix_test["G5", "F5"]
transition_matrix_test["F5", "G5"]
debugSource('B:/School/Master/Thesis/MasterThesis/music-analysis/model_training.R')
transition_matrix_test["F5", "G5"]
transition_matrix_test <- transitionMatrix(NULL, possibleNotes, notes_track1)
prev
curr
transition_matrix_test["A#4", "G5"]
curr
prev
transition_matrix_test["G5", "F5"]
transition_matrix["G5", "F5"]
transition_matrix_test <- transitionMatrix(NULL, possibleNotes, notes_track1)
transition_matrix_test["F5", "G5"]
transition_matrix_test["G5", "F5"]
?print
transitionMatrix <- function(transition_matrix, possibleNotes, notes){
#Initialize transition matrix
#TODO: Add initial note, so start note without any posterior
if(is.null(transition_matrix)){
transition_matrix <- matrix(rep(0,length(possibleNotes)*length(possibleNotes)), nrow=length(possibleNotes), ncol=length(possibleNotes))
#Add dimension names
dimnames(transition_matrix) <- list(possibleNotes, possibleNotes)
}
for(i in 1:length(notes)){
if(i == 1){next;}
prev <- notes[i-1]
curr <- notes[i]
cat("Previous note: ", prev)
cat("Current note: ", curr)
transition_matrix[prev,curr] <- transition_matrix[prev,curr] + 1
}
#Divide by univariate frequency to get probabilities
#transition_matrix <- t(t(transition_matrix) / frequencyVector[1,])
return(transition_matrix)
}
source('B:/School/Master/Thesis/MasterThesis/music-analysis/model_training.R')
transition_matrix_test <- transitionMatrix(NULL, possibleNotes, notes_track1)
notes[1]
prev
transition_matrix_test
View(transition_matrix)
rm(transition_matrix)
transition_matrix_test <- transitionMatrix(NULL, possibleNotes, notes_track1)
View(transition_matrix)
curr
prev
transition_matrix["A#4","G5"]
View(transition_matrix)
transition_matrix_test <- transitionMatrix(NULL, possibleNotes, notes_track1)
View(transition_matrix_test)
notes_track1
View(transition_matrix_test)
notes_track1[1]
notes_track1[2]
notes_track1[3]
transition_matrix_test[notes_track1[1], notes_track1[2]]
notes_track1[1]
notes_track1[2]
transition_matrix_test["A#4", "G5"]
transition_matrix_test[notes_track1[2], notes_track1[3]]
transition_matrix_test[notes_track1[3], notes_track1[4]]
transition_matrix_test[notes_track1[3], notes_track1[5]]
transition_matrix_test[notes_track1[3], notes_track1[6]]
notes_track1[3]
notes_track1[4]
notes_track1
toString(notes_track1[1])
transitionMatrix <- function(transition_matrix, possibleNotes, notes){
#Initialize transition matrix
#TODO: Add initial note, so start note without any posterior
if(is.null(transition_matrix)){
transition_matrix <- matrix(rep(0,length(possibleNotes)*length(possibleNotes)), nrow=length(possibleNotes), ncol=length(possibleNotes))
#Add dimension names
dimnames(transition_matrix) <- list(possibleNotes, possibleNotes)
}
for(i in 1:length(notes)){
if(i == 1){next;}
prev <- toString(notes[i-1])
curr <- toString(notes[i])
cat("Previous note: ", prev)
cat("Current note: ", curr)
transition_matrix[prev,curr] <- transition_matrix[prev,curr] + 1
}
#Divide by univariate frequency to get probabilities
#transition_matrix <- t(t(transition_matrix) / frequencyVector[1,])
return(transition_matrix)
}
transition_matrix_test <- transitionMatrix(NULL, possibleNotes, notes_track1)
transition_matrix_test["G5", "F5"]
transition_matrix_test["F5", "G5"]
View(transition_matrix_test)
transition_matrix_test["A5", "G5"]
transition_matrix_test["G5", "A5"]
plot(transition_matrix_test)
transition_matrix_test <- transition_matrix_test[, -(which(colSums(x) == 0))]
transition_matrix_test <- transition_matrix_test[, -(which(colSums(transition_matrix_test) == 0))]
View(transition_matrix_test)
?which
which(colSums(transition_matrix_test) == 0)
which(colSums(transition_matrix) == 0)
plot(transition_matrix_test[,1:4]
)
plot(transition_matrix_test[,1:30])
pairs(transition_matrix_test[,1:30])
pairs(transition_matrix_test[,1:4])
pairs(transition_matrix_test[,10:12])
install.packages("markovchain")
library(markovchain)
library("markovchain")
